实验一：LED发光二极管实验

1.	实验环境
1）	硬件：通用节点一个、USB仿真器、PC机；
2）	软件：IAR Embedded Workbench for MCS-51；

2.	实验内容
1）	熟悉Zigbee硬件模块相关接口；
2）	使用IAR 开发环境设计程序，利用CC2530 的IO口进行LED发光二极管的亮灭操作；

3.	实验原理
1）	硬件接口原理
在CC2530中，我们总共有3个可用的GPIO接口：P0、P1和P2。其中P0和P1的全部8位都有对应的引脚，而P2只有0-4几个引脚可用。这里我们主要对P0和P1共16个引脚进行操作，每个引脚都连接到一个发光二极管的驱动端，这样通过控制P0和P1的每一位，我们可以控制所有的16个发光二极管的亮灭。
首先我们需要了解CC2530 的IO口相关寄存器：
 
图5-1-1 P0和P1 寄存器
 
图5-1-2 P0SEL和P1SEL寄存器
 
 
图5-1-3 P0DIR和P1DIR寄存器
以上图表列出了我们需要用到的和P0、P1相关的寄存器，其中P0、P1寄存器为IO数据寄存器，P0SEL、P1SEL为外设功能选择寄存器，P0DIR、P1DIR为IO 输入输出选择寄存器，例程中我们需要对这几个寄存器进行IO配置相关设置和操作。此处如想深入了解请自行参考CC2530 的芯片手册。
 
图5-1-4 LED灯部分原理图
在这个例程中，我们需要点亮通用节点上的LED灯，上图给出了P0口控制D1~D8灯的原理图，P1口控制另8个灯原理类似。
 
图5-1-5  SN74LVC245原理框图
我们查看芯片SN74LVC245的器件手册，可以看到其工作原理框图如上所示。由图中描述可知，OEn信号控制所有引脚的输出使能，DIR信号控制信号驱动方向。我们的原理图中OEn接地，所以相应引脚是输出使能的。DIR（图中的T/Rn）是接高电平的，所以根据其原理框图，信号方向是由A到B。也就是A端的信号（P0.0-P0.7）经过SN74LVC245芯片后控制着B端输出信号（用来驱动D1~D8）。
R1和R2是330欧姆的排阻，每个LED灯串接一个，用来限制通过LED灯的电流，使LED灯工作在正常大小电流下，防止烧毁。
2）	软件设计
#include <ioCC2530.h>

#define D_COUNT   50        //通用延时时间计数

/***************************************
延时函数，n为延时周期计数
***************************************/
void Delay(unsigned int n)
{
  unsigned int t,tt;
  for(tt=0;tt<n;tt++)
    for(t=0;t<4000;t++)
      ;
}
/***************************************
程序主函数
***************************************/
void main( void )
{
  unsigned int i;
  P0DIR  = 0xff;          //设置P0口全部为输出
  P1DIR  = 0xff;          //设置P1口全部为输出
  P0 = 0xff;              //点亮所有灯
  P1 = 0xff;
  Delay(D_COUNT);Delay(D_COUNT);Delay(D_COUNT);
  P0 = 0;                 //熄灭所有灯
  P1 = 0;
  Delay(D_COUNT);Delay(D_COUNT);Delay(D_COUNT);
  while(1)
  {   
    for(i=0;i<8;i++)
    {
     
      
      P0 = 0x01<<i;
       P1 = 0x01<<i;//P0的第i位为1，其它位为0
      //P1_0 ^= 1;        //P1.0取反
      Delay(D_COUNT);      //设置IO状态后需要一个延时来让我们看到效果
    }
    P0 = 0;
    for(i=0;i<8;i++)
    {
      
      P1 = 0x01<<i;
      P0 = 0x01<<i;//P1的第i位为1，其它位为0
      //P0_0 ^= 1;       //P0.0取反
      Delay(D_COUNT);     //设置IO状态后需要一个延时来让我们看到效果
    }
    P1 = 0;
    
  }
}我们主要看main()函数中的代码，程序首先通过配置CC2530相关控制寄存器P0DIR、P1DIR来设置P0、P1工作于普通GPIO的输出模式。然后点亮所有灯，经过一个长延时后再熄灭所有灯，再经过一个长延时后进入程序主循环。在循环中首先依次将P0的某一位置1（从低到高，其他位为0，每次置位后在进行一个标准延时）。然后对P0所有位清0，接着对P1口执行以上类似操作。P1口操作结束后清0，再回到上面循环对P0口进行操作……
	由以上分析我们可以得到以下程序流程图：
 
图5-1-6  程序流程图
4.	实验步骤
	使用USB 仿真器连接PC 机和通用节点模块，模块电源开关处于中间“OFF”档，使用仿真器给模块供电。
	启动IAR 开发环境，打开“...\基础传感器实验\1-5基础例程\1-LED”目录下的实验工程。
	在IAR 开发环境中编译程序、点击 下载、调试程序。按“F5”使程序运行。
	观察现象，可以看到发光二极管轮流亮起。
	使用调试界面上的停止按钮 使程序停止，观察现象是否停止。
	使用调试界面上的go按钮 （等同“F5”），观察现象。


实验二：串口收发数据实验

5.	实验环境
3）	硬件：通用节点或任意传感器节点一个、USB仿真器、USB电缆、PC机；
4）	软件：IAR Embedded Workbench for MCS-51、串口调试工具；

6.	实验内容
3）	熟悉Zigbee硬件模块相关接口；
4）	使用IAR 开发环境设计程序，利用CC2530 的串口0 进行数据收发通讯；

7.	实验原理
3）	硬件接口原理
在CC2530中，我们总共有2个可用的串行接口，这些串行接口可被配置为标准串口或者SPI接口。这个例程中我们只使用USART0，并且工作在UART标准串口模式下。由于每种设置都有2套可用的IO映射，这里根据我们的硬件设置，我们应该使用其默认设置，UART0的TX和RX对应于P0_3和P0_2。
 
图5-2-1 部分外设复用IO对应图
首先我们需要了解CC2530 的IO口相关寄存器：
 
图5-2-2 P0 寄存器
 
图5-2-3 P0SEL 寄存器
  
图5-2-4 P0DIR 寄存器
以上图表列出了关于CC2530 处理器的P0 IO口相关的寄存器，其中P0 寄存器为IO数据寄存器，P0SEL为外设功能选择寄存器，P0DIR 为IO 输入输出选择寄存器，例程中我们需要对这3个寄存器进行IO配置相关设置，其他相关寄存器使用默认配置。如想深入了解请自行参考CC2530 的芯片手册。
其次，我们要对芯片的时钟操作有所了解，因为程序的启动部分，需要先对芯片时钟进行配置。
 
图5-2-5 CLKCONCMD 寄存器
 
图5-2-6 CLKCONSTA 寄存器
 
图5-2-7 SLEEP 控制寄存器
本例程中，程序通过配置以上寄存器将系统主时钟设置为片外32M晶振。
然后是串行接口外设相关寄存器，通过设置这些寄存器，我们将串行接口设定为预想的模式。
 
图5-2-8 PERCFG 寄存器
 
图5-2-9 U0CSR 寄存器
 
图5-2-10 U0GCR 寄存器
 
图5-2-11 U0BUF 寄存器
 
图5-2-12 U0BAUD 寄存器
以上图表列举了和CC2530串口操作定相关的寄存器，其中包括CLKCONCMD控制寄存器，用来控制系统时钟源，SLEEP 寄存器用来控制各种时钟源的开关和状态。PERCFG 寄存器为外设功能控制寄存器，用来控制外设功能模式。U0CSR、U0GCR、U0BUF、U0BAUD 等位串口相关寄存器。
 
图5-2-13 USB转串口部分原理图
	上图是节点的串口相关电路原理图。在这个图中，我们可以看到CH340芯片完成了USB转串口的工作，通过USB电缆连接节点和计算机后，CH340芯片会在计算机中虚拟一个串口，这个串口信号对于图中的CH340_TXD和CH340_RXD，通过J2上的跳线帽与CC2530的P0.2和P0.3引脚相连。
	通过之前的IO映射复用图我们可以发现，P0.2和P0.3对应的是USART0在UART模式下的RXT和TXD引脚。
4）	软件设计
#include "ioCC2530.h"
#include <string.h>

#define uint unsigned int
#define uchar unsigned char

//定义控制灯的端口
#define led1 P1_0
#define led2 P1_1

void InitIO(void);                          //IO初始化
void InitUart(void);                        //串口初始化
void SendString(char*string,uint legth);    //发送字符串
void Delay(unsigned int n);

uchar temp;               // 存放接受的数据

char wch[] ="Hello Word!\n";
char wch1[]="*************\n";
char wch2[]="你好！\n";

/*****************************************************************************
  功能描述: 延时
  Count:    延时单位数量 
*****************************************************************************/
void DelayXms(unsigned int Count)
{
 unsigned int i;
 unsigned int j;
 for(i = 0; i < Count; i++)
 {
    for( j=50000; j>0; j--);
 }
}
/*****************************************************************************
  功能描述: IO初始化
*****************************************************************************/
void InitIO(void)
{
    SLEEPCMD &= ~0X04;
    CLKCONCMD = 0X10;           //32k和32M时钟使用外部晶体，timer分频8M
    while(CLKCONSTA!=0X10);     //等待时钟切换
    SLEEPCMD = 0X04;	
    
    P2DIR = 0x00;              //高两位零   若设则最高优先USART0
    P1DIR|= 0X03;              //P1.0 P1.1 LEDs 灯端口配置
    P0DIR|= 0X00;              //input
    
    PERCFG = 0x00;              //UART0 默认端口
    P1SEL = 0X00;
    P0SEL = 0X0c;               //P0<3:2>设置成外围应用

}
/*****************************************************************************
  功能描述: 串口初始化
*****************************************************************************/
void InitUart(void)
{
    U0CSR |= 0x80;				//UART方式
    U0GCR = 11;				        //baud_e 波特率设为115200
    U0BAUD |= 216;				//baud_m = BaudRate*2^(28-buad_e)/32M-256
                                                //BaudRate=(256+baud_m)/2^(28-buad_e)x32MHz
    UTX0IF = 1;                                 //接收中断标记
    U0CSR |= 0X40;				//允许接收
    URX0IE = 1;                                 //接收中断使能
    EA =1;                                      //总中断开关打开
}
/*****************************************************************************
  功能描述: 串口发送字符串
  string:   字符串指针
  lenth：   长度
*****************************************************************************/
void SendString(char*string,uint lenth)
{
    uint j;
    for (j=0; j<lenth; j++)
    {
      U0DBUF = *string++;         //将要发送字符送入U0DBUF发送寄存器
      while(UTX0IF == 0);         //等待发送完成
      UTX0IF = 0;                 //清0标志位
    }
   
    
}
/*****************************************************************************
  功能描述:    主函数 
*****************************************************************************/
void Delay(unsigned int n)
{
  unsigned int t,tt;
  for(tt=0;tt<n;tt++)
    for(t=0;t<30000;t++)
      ;
}
 void main(void)
 {
    InitIO();
    InitUart();
    DelayXms(10);
   
    led1=1;                         //点亮2个LED灯
    led2=1;
    SendString(wch,sizeof(wch));
    
    Delay(50);
    SendString(wch1,sizeof(wch1));
   
    Delay(50);
    SendString(wch2,sizeof(wch2));
 
    
    while(1)
    {
      ; //进入无限循环等待中断函数被处触发
    }
 }
/*****************************************************************************
  功能描述: 串口中断函数
*****************************************************************************/
#pragma vector = URX0_VECTOR
__interrupt void UART0_ISR(void)
{
 	URX0IF = 0;			        //清中断标志
	temp = U0DBUF;
        U0DBUF = temp;                         //将收到的字符发送回去
        while(UTX0IF == 0);                    //等待发送
        UTX0IF = 0;                            //清发送标志
        led1 = ~led1;                          //指示中断活动
        led2 = ~led2;
}程序中主要有这几个函数：
DelayXms(unsigned int Count)：延时函数。
InitIO()：完成IO初始化功作。首先将系统切换到32Hz主晶振下工作并配置芯片内部频率，因为串口工作波特率较高，芯片对串口信息的处理要求其工作频率也较高，所以需要在32M频率下工作。然后配置相关IO寄存器，包括2个LED灯的控制IO口为输出模式，2个串口收发信号引脚为特殊功能应用模式。
InitUart()：完成串口的初始化工作。其中对串口寄存器进行设置，最重要的是串口的波特率设置。我们找到CC2530用户手册的P160页，其中有对波特率相关计算的详细描述。这里归纳其计算公式为：
 
其中BAUD_M和BAUD_E为相关寄存器中的设置位。下表归纳了在系统时钟为32MHz频率下的常用波特率对于设置值。
表5-2-1 系统时钟为32MHz时的常用波特率配置
 
这里通过配置CC2530 处理器的串口相关控制寄存器来设置串口0 的工作模式为串口模式，波特率为115200，使用中断方式接受串口数据并向串口输出。

SendString(char*string,uint legth)：完成从串口发送字符串。其中2个参数分别为发送字符串地址和字符串长度。
main()：主函数。完成各种初始化后进入循环等待串口接收中断被触法。
UART0_ISR()：串口接收中断函数。将收到的字符从串口发回。同时改变LED灯的状态，指示串口收到数据。
	主函数和中断函数的流程图如下：
 
图5-2-14 main函数和中断函数程序流程图
8.	实验步骤
	使用USB 仿真器连接PC 机和ZIGBEE模块。将系统配套USB线一端连接PC 机，一端连接ZIGBEE模块的MINI-USB接口上。
注意：如果使用通用节点运行本例程，请检查板子上的“TXD”和“RXD”位置跳线帽是否已经插上（右下图圆圈处），下方的电源开关打到“OFF”档，节点使用仿真器连接供电。
		如果使用传感器节点运行本例程，请检查板子上的“TXD”和“RXD”位置跳线帽是否已经插上（左下图圆圈处），下方的电源开关打到“OFF”档，节点使用仿真器连接供电。
    
图5-2-15 节点实物图（左为传感器节点，右为通用节点）
	连接USB电缆时，需要安装USB转串口的驱动程序，在“...\基础传感器实验\1-5基础例程\2-串口”目录下运行程序“CH341SER.EXE”安装驱动，重新拔插USB电缆，待驱动自动加载好，在“我的电脑右键——属性——设备管理器”中可以发现如下虚拟串口条目“USB-SERIAL CH340（COMXX）”。记住这里的串口号码“COMXX”。
 
图5-2-16 查看串口号
	启动IAR 开发环境，打开“...\基础传感器实验\1-5基础例程\2-串口”目录下的实验工程。
	在IAR 开发环境中编译程序、点击 下载、调试程序。按“F5”使程序运行。
	打开“...\基础传感器实验\1-5基础例程\2-串口”目录下的串口调试程序“串口调试程序（支持中文）.EXE”。按照下图设置这几项：串口号选择刚刚在设备管理器中记下的串口号；波特率选择“115200”；数据位8位；停止位1位；校验位none；流控制none等其他均为默认。点击右下角的发送数据按钮，可以看到接受文本框中显示接受到同样的数据。
	更换发送文本框“字符串输入框”中的内容，点击发送按钮。可以看到相同的字符串又被返回。
 
图5-2-17 例程运行结果



 


实验三：按键控制实验

9.	实验环境
5）	硬件：传感器节点一个、USB仿真器、PC机；
6）	软件：IAR Embedded Workbench for MCS-51；

10.	实验内容
5）	熟悉Zigbee硬件模块相关接口；
6）	使用IAR 开发环境设计程序，利用CC2530 的GPIO读取按键值并相应对进行LED发光二极管的亮灭操作；

11.	实验原理
5）	硬件接口原理
如图所示，按键部分的电路图比较简单。UserINT信号连接的是芯片的P2.0引脚，在按键没有被按下时（处于断开状态），经过电阻R9的上拉作用，UserINT信号是处于高电平的，而当按键按下时，UserINT信号直接和地相连，这样处于低电平。在芯片内通过检测P2.0口的输出状态就可以知道按键的状态。电容C4在按键松开的时候起到对输出信号的缓冲作用，这样可以过滤掉部分干扰信号，使得输出信号较为平滑。
 
图5-3-1 按键部分电路原理图
6）	软件设计
#include <ioCC2530.h>

#define D_COUNT   50        //标准延时周期计数
#define KEY_INPUT P2_0      //定义按键引脚
/*****************************************************************************
  功能描述: 延时
  Count:    延时单位数量 
*****************************************************************************/
void Delay(unsigned int n)
{
  unsigned int t,tt;
  for(tt=0;tt<n;tt++)
    for(t=0;t<1000;t++)
      ;
}
/*****************************************************************************
  功能描述:    主函数 
*****************************************************************************/
void main( void )
{
  unsigned int i;
  P0DIR  = 0x00;          //P0口全部为输入
  P1DIR  = 0x03;          //P1口低2位输出，其他输入
  P1 = 0;
  
/*  P2IEN |= 0x01;        //配置IO中断寄存器    
  PICTL |= 0x04;
  IEN2 |= 0x02;
  P2IFG = 0x0;          
  EA = 1;               //中断总开关
  while(1){}            //程序无限循环
*/
  
  Delay(D_COUNT);Delay(D_COUNT);Delay(D_COUNT);
  while(1)
  {
    if(!KEY_INPUT)        //判断按键是否按下
    {
      i++;
      P1 = i&0x03;          //P1低2位赋值为i的低2位
      Delay(100);           //延时，加长2次判断间隔
    }
    Delay(10);
  }
}

/*****************************************************************************
  功能描述: 串口中断函数
*****************************************************************************/
/*
#pragma vector = P2INT_VECTOR
__interrupt void P2_ISR(void)
{
  Delay(D_COUNT);
  P1 += 1;
  P2IFG = 0x0;    //清中断标志
  P2IF=0;         //清中断标志
}
*/程序通过读取P2.0的信息来获得按键的状态，同时对P1上的2个发光二极管进行操作。程序中的长延时是为了使得一定时间内的按下只被识别为一次按下，短延时是为了滤掉可能的干扰信号。程序的流程图如下。
 
图5-3-2 程序流程图
12.	实验步骤
	使用USB 仿真器连接PC 机和任意一个传感器节点模块，模块电源开关处于“ON”档，使用电池给模块供电（如电池电量低插上USB电缆，可一边充电一边使用）。
	启动IAR 开发环境，打开“...\基础传感器实验\1-5基础例程\3-按键控制”目录下的实验工程。
	在IAR 开发环境中编译程序、点击 下载、调试程序。按“F5”使程序运行。
	观察现象，可以看到2个发光二极管都没有亮起。
	按下模块中间的“KEY”按键，观察2个发光二极管的状态。
	重复按键操作，尝试长按或短按，观察发光二极管状态。修改程序中的延时数值（下图中红点行）后再重复上面操作，体会不同延时下的效果。
 


